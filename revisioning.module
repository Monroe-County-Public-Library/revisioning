<?php

/**
 * @file
 * Allows content to be updated and reviewed before submitting it for
 * publication, while the current live revision remains unchanged and publicly
 * visible until the changes have been reviewed and found fit for publication
 * by a moderator.
 */

define('REVISIONING_LOAD_CURRENT', 0); // node/%nid/view, node/%nid/edit opens current revision
define('REVISIONING_LOAD_LATEST',  1); // node/%nid/view, node/%nid/edit opens latest revison

define('NEW_REVISION_WHEN_NOT_PENDING', 0);
define('NEW_REVISION_EVERY_SAVE', 1);

define('REVISIONS_BLOCK_OLDEST_AT_TOP', 0);
define('REVISIONS_BLOCK_NEWEST_AT_TOP', 1);

require_once drupal_get_path('module', 'revisioning') . '/revisioning_api.inc';
require_once drupal_get_path('module', 'revisioning') . '/revisioning.pages.inc';
require_once drupal_get_path('module', 'revisioning') . '/revisioning_theme.inc';
require_once drupal_get_path('module', 'revisioning') . '/revisioning_tokens.inc';
require_once drupal_get_path('module', 'revisioning') . '/revisioning_triggers_actions.inc';
// No need to include Rules integration file - Rules module does it for us automatically.

/**
 * Implements hook_help().
 */
function revisioning_help($path, $arg) {
  switch ($path) {
    case 'admin/help#revisioning':
      $s = t('For documentation and tutorials see the <a href="@revisioning">Revisioning project page</a>',
        array('@revisioning' => url('http://drupal.org/project/revisioning')));
      break;
    case 'node/%/revisions':
      $s = t('To edit, publish or delete one of the revisions below, click on its saved date.');
      break;
    case 'admin/structure/trigger/revisioning':
      $s = t("Below you can assign actions to run when certain publication-related events happen. For example, you could send an e-mail to an author when their pending content is pubished.");
      break;
    case 'accessible-content/i-created/pending':
      $s = t('Showing all <em>pending</em> content <em>you created</em> and still have at least view access to.');
      break;
    case 'accessible-content/i-last-modified/pending':
      $s = t('Showing all <em>pending</em> content <em>you last modified</em> and still have at least view access to.');
      break;
    case 'accessible-content/i-can-edit/pending':
      $s = t('Showing all <em>pending</em> content you can <em>edit</em>.');
      break;
    case 'accessible-content/i-can-view/pending':
      $s = t('Showing all <em>pending</em> content you have at least <em>view</em> access to.');
      break;
  }
  return empty($s) ? '' : $s . '<br/>';
}

/**
 * Implements hook_permission().
 *
 * Revisioning permissions. Note that permissions to view, revert and delete
 * revisions already exist in node.module.
 */
function revisioning_permission() {
  $permissions = module_exists('module_grants_monitor')
    ? array('access Pending tab' => array(
      'title' => t('Access Pending tab'),
      'description' => ''))
    : array();

  $moderated_content_types = implode(', ', revisioning_moderated_content_types(FALSE));
  $publish_description = empty($moderated_content_types)
    ? t('Please select one or more content types for moderation by ticking the <em>New revision in draft, pending moderation</em> <strong>Publishing option</strong> at <em>Structure >> Content types >> edit</em>.')
    : t('Applies only to content types that are subject to moderation, i.e.: %moderated_content_types.',
        array('%moderated_content_types' => $moderated_content_types));

  $permissions = array_merge($permissions, array(
    'view revision status messages' => array(
      'title' => t('View revision status messages'),
      'description' => ''
    ),
    'edit revisions' => array(
      'title' => t('Edit content revisions'),
      'description' => t('Also requires edit permission from either the Node or other content access module(s).')
    ),
    'publish revisions' => array(
      'title' => t('Publish content revisions'),
      'description' => $publish_description
    ),
    'unpublish current revision' => array(
      'title' => t('Unpublish current revision'),
      'description' => $publish_description
    )
  ));
  // Add per node-type view permissions in same way as edit permissions of node
  // module, but only for moderated content-types.
  foreach (node_type_get_types() as $type) {
    $machine_name = check_plain($type->type);
    if (revisioning_content_is_moderated($machine_name)) {
      $permissions['view revisions of own ' . $machine_name . ' content'] = array(
        'title' => t('%type-name: View revisions of own content', array('%type-name' => $type->name)),
        'description' => t('Grants access to published as well as unpublished %type-name content.', array('%type-name' => $type->name)));
      $permissions['view revisions of any ' . $machine_name . ' content'] = array(
        'title' => t('%type-name: View revisions of any content', array('%type-name' => $type->name)),
        'description' => t('Grants access to published as well as unpublished %type-name content.', array('%type-name' => $type->name)));
    }
  }
  return $permissions;
}

/**
 * Implements hook_menu().
 *
 * Define new menu items.
 * Existing menu items are modified through hook_menu_alter().
 */
function revisioning_menu() {
  $items = array();

  // Start with the Revisioning config menu item, put under Content Authoring
  $items['admin/config/content/revisioning'] = array(
    'title' => 'Revisioning',
    'description' => 'Configure how content view and edit links behave. Customise revision summary listing.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('revisioning_admin_configure'),
    'access arguments' => array('administer site configuration'),
    'file' => 'revisioning.admin.inc'
  );

  // Plain link, not a tab, to allow users to unpublish a node.
  $items['node/%node/unpublish'] = array(
  //'title' => t(Unpublish current revision'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('revisioning_unpublish_confirm', 1),
    'access callback' => '_revisioning_access_node_revision',
    'access arguments' => array('unpublish current revision', 1),
    'type' => MENU_CALLBACK,
  );

  // Revision tab local subtasks (i.e. secondary tabs), up to 8 of them:
  // list, view, edit, publish, unpublish, revert, delete and compare.
  // All revision operations 'node/%node/revisions/%vid/<op>' are defined as
  // local subtasks (subtabs) secondary to the primary 'node/%node/revisions'
  // local task (primary tab).
  // Note the use of %vid as opposed to %. This allows us to manipulate the 
  // second argument in the path through vid_to_arg().

  // Subtab to the Revisions primary tab to allow going back to the revisions
  // list without clicking the primary tab for a second time, which also works.
  $items['node/%node/revisions/list'] = array(
    'title' => 'List all revisions',
    'access callback' => '_revisioning_access_node_revision',
    'access arguments' => array('view revision list', 1),
    'type' => MENU_LOCAL_TASK,
    'weight' => -20,
  );

  // View revision local subtask
  $items['node/%node/revisions/%vid/view'] = array(
    'title' => 'View',
    'load arguments' => array(3),
    'page callback' => '_revisioning_view_revision',
    'page arguments' => array(1),
    'access callback' => '_revisioning_access_node_revision',
    'access arguments' => array('view revisions', 1),
    'type' => MENU_LOCAL_TASK,
    'weight' => -10,
  //'tab_parent' => 'node/%/revisions',
  );
  // Edit revision local subtask
  $items['node/%node/revisions/%vid/edit'] = array(
    'title' => 'Edit',
    'load arguments' => array(3),
    'page callback' => '_revisioning_edit_revision',
    'page arguments' => array(1),
    'access callback' => '_revisioning_access_node_revision',
    'access arguments' => array('edit revisions', 1),
    'file' => 'node.pages.inc',
    'file path' => drupal_get_path('module', 'node'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -7,
  //'tab_parent' => 'node/%/revisions',
  );
  // Publish revision local subtask.
  // As the menu is content type unaware, a further check on 
  // node->revision_moderation must be made to determine whether it is
  // appropriate to show this tab. 
  // This is done in _revisioning_access_node_revision.
  $items['node/%node/revisions/%vid/publish'] = array(
    'title' => 'Publish this',
    'load arguments' => array(3),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('revisioning_publish_confirm', 1),
    'access callback' => '_revisioning_access_node_revision',
    'access arguments' => array('publish revisions', 1),
    'type' => MENU_LOCAL_TASK,
    'weight' => -4,
  //'tab_parent' => 'node/%/revisions',
  );
  // Unpublish node local subtask.
  // As the menu is content type unaware, a further check on 
  // node->revision_moderation must be made to determine whether it is
  // appropriate to show this tab. 
  // This is done in _revisioning_access_node_revision.
  $items['node/%node/revisions/%vid/unpublish'] = array(
    'title' => 'Unpublish this',
    'load arguments' => array(3),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('revisioning_unpublish_confirm', 1),
    'access callback' => '_revisioning_access_node_revision',
    'access arguments' => array('unpublish current revision', 1),
    'type' => MENU_LOCAL_TASK,
    'weight' => -3,
  //'tab_parent' => 'node/%/revisions',
  );
  // Revert to revision local subtask.
  $items['node/%node/revisions/%vid/revert'] = array(
    'title' => 'Revert to this',
    'load arguments' => array(3),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('node_revision_revert_confirm', 1),
    'access callback' => '_revisioning_access_node_revision',
    'access arguments' => array('revert revisions', 1),
    'file' => 'node.pages.inc',
    'file path' => drupal_get_path('module', 'node'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -2,
  //'tab_parent' => 'node/%/revisions',
  );
  // Delete revision local subtask.
  $items['node/%node/revisions/%vid/delete'] = array(
    'title' => 'Delete',
    'load arguments' => array(3),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('node_revision_delete_confirm', 1),
    'access callback' => '_revisioning_access_node_revision',
    'access arguments' => array('delete revisions', 1),
    'file' => 'node.pages.inc',
    'file path' => drupal_get_path('module', 'node'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
  //'tab_parent' => 'node/%/revisions',
  );

  // If Diff module is enabled, provide a "Compare to current" local subtask
  if (module_exists('diff')) {
    $items['node/%node/revisions/%vid/compare'] = array(
      'title' => 'Compare to current',
      'load arguments' => array(3),
      'page callback' => '_revisioning_compare_to_current_revision',
      'page arguments' => array(1),
      'access callback' => '_revisioning_access_node_revision',
      'access arguments' => array('compare to current', 1),
      'type' => MENU_LOCAL_TASK,
      'weight' => 0,
    //'tab_parent' => 'node/%/revisions',
    );
  }
/*
  if (module_exists('module_grants_monitor')) {
    // Add a tab to the 'I created' tab (defined in module_grants_monitor.module)
    $items['accessible-content/i-created/pending'] = array(
      'title' => 'In draft/Pending publication',
      'page callback' => '_revisioning_show_pending_nodes',
      'page arguments' => array('view', I_CREATED),
      'access callback' => 'revisioning_user_access_all',
      'access arguments' => array(array('access I Created tab', 'access Pending tab')),
      'type' => MENU_LOCAL_TASK,
      'weight' => -1
    );
    // Add a tab to the 'I last modified' tab
    $items['accessible-content/i-last-modified/pending'] = array(
      'title' => 'In draft/Pending publication',
      'page callback' => '_revisioning_show_pending_nodes',
      'page arguments' => array('view', I_LAST_MODIFIED),
      'access callback' => 'revisioning_user_access_al',
      'access arguments' => array(array('access I Last Modified tab', 'access Pending tab')),
      'type' => MENU_LOCAL_TASK,
      'weight' => -1
    );
    // Add a tab to the 'I can edit' tab
    $items['accessible-content/i-can-edit/pending'] = array(
      'title' => 'In draft/Pending publication',
      'page callback' => '_revisioning_show_pending_nodes',
      'page arguments' => array('update'),
      'access callback' => 'revisioning_user_access_all',
      'access arguments' => array(array('access I Can Edit tab', 'access Pending tab')),
      'type' => MENU_LOCAL_TASK,
      'weight' => -1
    );
    // Add a tab to the 'I can view' tab (defined in module_grants.module)
    $items['accessible-content/i-can-view/pending'] = array(
      'title' => 'In draft/Pending publication',
      'page callback' => '_revisioning_show_pending_nodes',
      'page arguments' => array('view'),
      'access callback' => 'revisioning_user_access_all',
      'access arguments' => array(array('access I Can View tab', 'access Pending tab')),
      'type' => MENU_LOCAL_TASK,
      'weight' => -1
    );
  }
*/
  return $items;
}

/**
 * Implements hook_menu_alter().
 *
 * Modify menu items defined in other modules (in particular the Node and
 * Module Grants modules).
 */
function revisioning_menu_alter(&$items) {

  // Change to access callbacks for existing node paths so that we properly
  // control revision-related operation.
  // Some also have their page callbacks altered, e.g to load the latest
  // rather than the current revision of a node.
  // Can't change node load function to, say nid_load(), as we'll run into
  // trouble elsewhere, e.g. menu_get_object(), due to the fact that the
  // prefix, e.g. '%nid', is meant to be a type name, i.e. '%node'.

  // Alter the 3 primary node page tabs: View tab, Edit tab, Revisions tab ...
  $items['node/%node']['access callback'] = '_revisioning_view_edit_access_callback';
  $items['node/%node']['access arguments'] = array('view', 1);
  $items['node/%node']['page callback'] = '_revisioning_view';
  $items['node/%node']['page arguments'] = array(1);
  // This is the MENU_DEFAULT_LOCAL_TASK, so inherits the above.
  $items['node/%node/view']['title callback'] = '_revisioning_title_for_tab';
  $items['node/%node/view']['title arguments'] = array(1, FALSE);
  $items['node/%node/view']['weight'] = -10;
//$items['node/%node/view']['type'] = MENU_DEFAULT_LOCAL_TASK;
  $items['node/%node/edit']['access callback'] = '_revisioning_view_edit_access_callback';
  $items['node/%node/edit']['access arguments'] = array('edit', 1);
  $items['node/%node/edit']['page callback'] = '_revisioning_edit';
  $items['node/%node/edit']['page arguments'] = array(1);
  $items['node/%node/edit']['title callback'] = '_revisioning_title_for_tab';
  $items['node/%node/edit']['title arguments'] = array(1, TRUE);
//$items['node/%node/edit']['type'] = MENU_LOCAL_TASK;
//$items['node/%node/edit']['context'] = MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE;
//$items['node/%node/edit']['weight'] = 0;

  // 'Revisions' tab remains, but points to new page callback, allowing users
  // to pick the revision to view, edit, publish, revert, unpublish, delete.
  // Need to override _node_revision_access() call back as it disallows access
  // to the 'Revisions' tab when there's only one revision, which will prevent
  // users from getting to the publish/unpublish links.
  $items['node/%node/revisions']['access callback'] = '_revisioning_access_node_revision';
  $items['node/%node/revisions']['access arguments'] = array('view revision list', 1);
  $items['node/%node/revisions']['page callback'] = 'revisioning_node_overview';
  $items['node/%node/revisions']['page arguments'] = array(1);
//$items['node/%node/revisions']['type'] = MENU_LOCAL_TASK;
//$items['node/%node/revisions']['weight'] = 2;

  // Remove the node.module links as we defined our own versions, using %vid
  unset($items['node/%node/revisions/%/view']);
  unset($items['node/%node/revisions/%/revert']);
  unset($items['node/%node/revisions/%/delete']);
  
  if (module_exists('diff')) {
    // If Diff module is enabled, make sure it uses correct access callback
    $items['node/%node/revisions/view/%/%']['access callback'] = '_revisioning_access_node_revision';
    $items['node/%node/revisions/view/%/%']['access arguments'] = array('view revisions', 1);
  }
}

/**
 * Node load_function called for all 'node/%nid/...' menu items defined above.
 * The default node_load() function from the node.module would have been fine,
 * if it wasn't for bug [#1120272].
 * node_load() first loads the {node} table data, then attaches to it the 
 * {node_revision} data. If $vid is empty, we need to specify one, or the object
 * returned may be inconsistent [#1120272]. We choose the current vid, as the
 * user may not have permission to 'view revisions'. We don't know the details
 * until the {node} part (e.g. node type) is loaded. So we do this and let
 * the access callback _revisioning_view_edit_access_callback() assess further
 * details.
 * This approach was abandoned as we ran into trouble elsewhere. 'nid' is
 * expected to be a type name, i.e. 'node'.
 *
function nid_load($nid, $vid = NULL) {
  if (empty($vid)) {
    // Work around D7 bug [#1120272] by passing current vid explicitly
    $vid = revisioning_get_current_node_revision_id($nid);
  }
  return node_load($nid, $vid); // indirectly invokes hook_node_load()
}
*/

/**
 * Perform path manipulations for menu items containing the %vid wildcard, ie
 * the ones from revisioning_menu().
 * $map contains what arg() returns, eg $map[0]=='node', $map[1]=='123'...
 * For the case where $arg could not be estatblished $index==3
 * @see http://drupal.org/node/500864
 */
function vid_to_arg($arg, &$map, $index) {
  return $arg; // empty($arg) ? revisioning_get_current_node_revision_id($map[1]) : $arg;
}

/**
 * Implements hook_node_load().
 *
 * The same load op may occur multiple times during the same HTTP request, so
 * hooray for caching!
 *
 * hook_node_load is called when viewing a single node (i.e. $nodes has one element)
 * node_load() -> node_load_multiple() -> DrupalDefaultEntityController->attachLoad()
 *
 * hook_node_load is also called on the /content summary page:
 * node_admin_nodes() -> node_load_multiple() -> DrupalDefaultEntityController->attachLoad()
 * @TODO Do nothing in this 2nd case?
 *
 * @param $nodes
 * @param $types
 */
function revisioning_node_load($nodes, $types) {
  if (count($nodes) != 1) {
    return;
  }
  $node = reset($nodes); // to get first node
  revisioning_set_basic_node_revision_info($node);
  if (!empty($node->revision_moderation) && !empty($node->is_current)) {
    // Hack!
    // Because of core bug [#1120272], if the current revision is loaded,
    // $node body and fields may in fact be that of the LATEST revision.
    // So reload with FIELD_LOAD_REVISION ($node->vid is already set correctly).
    // Make sure to unset the already loaded fields or we end up with two
    // copies of each field, e.g. 2 tags, 2 image attachments etc.
    list($id, $vid, $bundle) = entity_extract_ids('node', $node);
    $options = array('deleted' => FALSE);
    $instances = _field_invoke_get_instances('node', $bundle, $options);
    foreach ($instances as $instance) {
      $field_name = $instance['field_name'];
      unset($node->{$field_name});
    }
    field_attach_load('node', $nodes, FIELD_LOAD_REVISION, $options);
  }
}

function revisioning_set_status_message($message) {
  if (user_access('view revision status messages')) {
    drupal_set_message($message, 'status');
  }
}

/**
 * Implements hook_node_prepare().
 *
 * Called when presenting edit form.
 */
function revisioning_node_prepare($node) {
  if (!empty($node->nid)) {
    $count = _revisioning_get_number_of_revisions_newer_than($node->vid, $node->nid);
    if ($count == 1) {
      drupal_set_message(t('Please note there is one revision more recent than the one you are about to edit.'), 'warning');
    }
    elseif ($count > 1) {
      drupal_set_message(t('Please note there are !count revisions more recent than the one you are about to edit.', array('!count' => check_plain($count))), 'warning');
    }
  }
}

/**
 * Implements hook_node_presave().
 *
 * Called when saving, be it an edit or when creating a node.
 */
function revisioning_node_presave($node) {
  revisioning_set_basic_node_revision_info($node);
  if (!empty($node->revision_moderation)) {
    //$node->is_pending = _revisioning_node_is_pending($node); // set by revisioning_node_load, if not new
    if (!empty($node->revision) && $node->is_pending && variable_get('new_revisions_' . $node->type, NEW_REVISION_WHEN_NOT_PENDING) == NEW_REVISION_WHEN_NOT_PENDING) {
      revisioning_set_status_message(t('Updating existing copy, not creating new revision as this one is still pending.'));
      // Update the $node object just before it is saved to the db
      $node->revision = FALSE;
    }
    // Save title of current revision to restore at revisioning_node_update() time
    $result = db_query("SELECT title FROM {node} n WHERE n.nid = :nid", array(':nid' => $node->nid));
    $node->current_title = $result->fetchField();
    if (user_access('publish revisions') && variable_get('revisioning_auto_publish_' . $node->type, FALSE)) {
      revisioning_set_status_message(t('Auto-publishing this revision.'));
      $node->status = NODE_PUBLISHED;
      // Make sure the 'update' does NOT reset vid, so that new revision becomes current
      unset($node->current_revision_id);
    }
  }
}

/**
 * Implements hook_node_insert().
 *
 * New node.
 */
function revisioning_node_insert($node) {
  // Can't check for $node->revision_moderation, as this set via 
  // hook_node_load(), which isn't called for an insert.
  if (revisioning_content_is_moderated($node->type)) {
    revisioning_set_status_message($node->status
      ? t('Initial revision created and published.')
      : t('Initial draft created, pending publication.')
    );
  }
}

/**
 * Implements hook_node_update().
 */
function revisioning_node_update($node) {
  if (empty($node->revision_moderation)) {
    return;
  }
  if (empty($node->revision)) { // update only, no new revision is to be created
    // function _node_save_revision($node) sets the $node->vid to the latest
    // revision -- need to undo.
    db_query("UPDATE {node} SET vid = :vid WHERE nid = :nid", array(
       ':vid' => $node->current_revision_id,
       ':nid' => $node->nid));
  }
  elseif (!empty($node->current_revision_id) && $node->current_revision_id != $node->vid) {
    // Resetting title and vid back to their originial values, thus creating pending revision.
    // Note: cannot use old_vid as set by node_save(), as this refers to revision edited.
    db_query("UPDATE {node} SET vid = :vid, title = :title WHERE nid = :nid", array(
       ':vid' => $node->current_revision_id,
       ':title' => $node->current_title,
       ':nid' => $node->nid));
  }
}

/**
 * Implements hook_views_api().
 */
function revisioning_views_api() {
  return array(
    'api' => views_api_version(),
    'path' => drupal_get_path('module', 'revisioning') . '/views'
  );
}

/**
 * Implements hook_user_node_access().
 *
 * @see module_grants_node_revision_access()
 *
 * @param $revision_op
 *   node or revision operation e.g. 'view revisions'
 * @param $node
 * @return the associated node operation required for this revision_op, or
 *   FALSE if access to the node is to be denied.
 *   Valid node operations to return are 'view', 'update', 'delete'.
 */
function revisioning_user_node_access($revision_op, $node) {
  global $user;

  switch ($revision_op) {
    case 'view current':
      break;
    case 'compare to current':
    case 'view revisions':
    case 'view revision list':
      if (user_access('view revisions', $user)) {
        break;
      }
      $type = check_plain($node->type);
      if (user_access('view revisions of any ' . $type . ' content', $user)) {
        break;
      }
      if (($node->uid == $user->uid) && user_access('view revisions of own ' . $type . ' content', $user)) {
        break;
      }
      return FALSE;

    case 'edit current':
      return 'update';

    case 'edit revisions':
    case 'revert revisions':
      return user_access($revision_op, $user) ? 'update' : FALSE;

    case 'publish revisions':
    case 'unpublish current revision':
      return user_access($revision_op, $user) ? 'view' : FALSE;

    case 'delete revisions':
      if (!user_access($revision_op, $user)) {
        return FALSE;
      }
    case 'delete node':
      return 'delete';

    default:
      drupal_set_message(t("Unknown Revisioning operation '%revision_op'. Treating as 'view'.",
        array('%revision_op' => $revision_op)), 'warning', FALSE);
  }
  return 'view';
}

/**
 * Test whether the supplied revision operation is appropriate for the node.
 * This is irrespective of user permissions, e.g. even for an administrator it
 * doesn't make sense to publish a node that is already published or to
 * "revert" to the current revision.
 *
 * @param $revision_op
 * @param $node
 * @return TRUE if the operation is appropriate for this node at this point
 */
function _revisioning_operation_appropriate($revision_op, $node) {

  switch ($revision_op) {

    case 'compare to current':
      // Can't compare against itself
    case 'delete revisions':
      // If the revision is the current one, suppress the delete operation
      // @TODO ...unless it's the only revision, in which case delete the
      // entire node; however this requires a different URL.
      return !$node->is_current;

    case 'view revision list': // i.e. node revisions summary
      if ($node->num_revisions == 1 && empty($node->revision_moderation)
        /* && (module_exists('module_grants') ? !module_grants_node_access('delete', $node) : !node_access('delete', $node))*/) {
        // Suppress Revisions tab when when there's only 1 revision -- consistent with core.
        // However, when content is moderated (i.e. "New revision in draft,
        // pending moderation" is ticked) we want to be able to get to the
        // 'Unpublish current' link on this page and the 'Publish this' tab on
        // the next. Also when user has permission to delete node, we need to
        // present the Delete link, unless we assume that this privilege
        // assumes the 'edit' permission.
        return FALSE;
      }
      break;
      
    case 'edit revisions':
      if (empty($node->revision_moderation) /* && !$node->is_current*/) {
        return FALSE;
      }
      break;

    case 'publish revisions':
      // If the node isn't meant to be moderated,
      // or the revision is not either pending or current but not published,
      // then disallow publication.
      if (empty($node->revision_moderation) ||
          !($node->is_pending || ($node->is_current && !$node->status))) {
        return FALSE;
      }
      break;

    case 'unpublish current revision':
      // If the node isn't meant to be moderated or it is unpublished already 
      // or we're not looking at the current revision, then unpublish is not an
      // option.
      if (empty($node->revision_moderation) || !$node->status || !$node->is_current) {
        return FALSE;
      }
      break;

    case 'revert revisions':
      // If this revision is pending or current, suppress the reversion
      if ($node->is_pending || $node->is_current) {
        return FALSE;
      }
      break;
  }
  return TRUE;
}

/**
 * Determine whether the supplied revision operation is permitted on the node.
 * This requires getting through three levels of defence:
 * o Is the operation appropriate for this node at this time, e.g. a node must
 *   not be published if it already is or if it isn't under moderation control
 * o Does the user have permission for the requested REVISION operation?
 * o Does the user have the NODE access rights (view/update/delete) for this 
 *   operation?
 *
 * @param $revision_op
 *   For instance 'publish revisions', 'delete revisions'
 * @param $node
 * @return bool
 */
function _revisioning_access_node_revision($revision_op, $node) {

  if (!_revisioning_operation_appropriate($revision_op, $node)) {
    return FALSE;
  }
  if (module_exists('module_grants')) {
    $access = module_grants_node_revision_access($revision_op, $node);
  }
  else {
    // Check the revision-aspect of the operation
    $node_op = revisioning_user_node_access($revision_op, $node);
    // ... then check with core to assess node permissions
    // node_access will invoke hook_node_access(), i.e. revisioning_node_access().
    $access = $node_op && node_access($node_op, $node);
  }
  return $access;
}

/**
 * Implements hook_node_access().
 * 
 * This gets invoked from node.module/node_access() after it has checked the
 * standard node permissions using node_node_access() and just before it checks
 * the node_access grants table. 
 * We basically return "don't care" except for one 'view. case, which replicates
 * the node.module. "Don't care" in this case would result in "access denied".
 */
function revisioning_node_access($node, $node_op, $account) {
  // Taken from node.module/node_access():
  // If no modules implement hook_node_grants(), the default behaviour is to
  // allow all users to view published nodes, so reflect that here,
  // augmented for the 'view revisions' family of permissions, which apply to
  // both published and unpublished nodes.
  if ($node_op == 'view' && !module_implements('node_grants') &&
     ($node->status == NODE_PUBLISHED || revisioning_user_node_access('view revisions', $node))) {
    return NODE_ACCESS_ALLOW;
  }
  return NODE_ACCESS_IGNORE;
}

/**
 * Access callback for 'node/%', 'node/%/view' and 'node/%/edit' links that
 * may appear anywhere on the site.
 * At the time that this function is called the CURRENT revision will already
 * have been loaded by the system. However depending on the value of the
 * 'revisioning_view_callback' and 'revisioning_edit_callback' variables (as
 * set on the admin/config/content/revisioning page), this may not be the 
 * desired revision.
 * If these variables state that the LATEST revision should be loaded, we need
 * to check at this point whether the user has permission to view this revision.
 *
 * The 'View current' and/or 'Edit current' tabs are suppressed when the current
 * revision is already displayed via one of the Revisions subtabs.
 * The 'View latest' and/or 'Edit latest' tabs are suppressed when the latest
 * revision is already displayed via one of the Revisions subtabs.
 *
 * @param op, must be one of 'view' or 'edit'
 * @param $node
 * @return FALSE if access to the desired revision is denied
 *
 */
function _revisioning_view_edit_access_callback($op, $node) {

  $load_op = _revisioning_load_op($node, $op);

  $vid = arg(3);
  if (!empty($node->revision_moderation) && is_numeric($vid)) {
    // The View, Edit primary tabs are requested indirectly, in the context of
    // the secondary tabs under Revisions, e.g. node/%/revisions/%
    if ($load_op == REVISIONING_LOAD_CURRENT && $vid == $node->current_revision_id) {
      // Suppress 'View current' and 'Edit current' primary tabs when viewing current
      return FALSE;
    }
    if ($load_op == REVISIONING_LOAD_LATEST && $vid == revisioning_get_latest_revision_id($node->nid)) {
      // Suppress 'View latest' and 'Edit latest' primary tabs when viewing latest
      return FALSE;
    }
  }
  if ($load_op == REVISIONING_LOAD_LATEST) {
    // _revisioning_load_op has already checked permission to view latest
    return TRUE;
  }
  $revision_op = ($op == 'view') ? 'view current' : 'edit current';
  return _revisioning_access_node_revision($revision_op, $node);
}

/**
 * Assuming that the node passed in is the current revision (core default),
 * this function determines whether the lastest revision should be loaded
 * instead, in which case it returns REVISIONING_LOAD_LATEST.
 *
 * @param $node, only nodes of content types subject to moderation are 
 *   processed by this function
 * @param $op, either 'edit' or 'view'
 * @param $check_access, whether revision access permissions should be
 *   checked; if the user has no permission to load the latest revisions, then
 *   the function returns REVISIONING_LOAD_CURRENT
 */
function _revisioning_load_op($node, $op, $check_access = TRUE) {
  if (!empty($node->revision_moderation)) {
    $view_mode = (int)variable_get('revisioning_view_callback', REVISIONING_LOAD_CURRENT);
    $edit_mode = (int)variable_get('revisioning_edit_callback', REVISIONING_LOAD_CURRENT);
    $load_op = ($op == 'edit') ? $edit_mode : $view_mode;
    if ($load_op == REVISIONING_LOAD_LATEST) {
      // Site is configured to load latest revision, but we'll only do this if
      // the latest isn't loaded already and the user has the permission to do so.
      $latest_vid = revisioning_get_latest_revision_id($node->nid);
      if ($latest_vid != $node->current_revision_id) {
        if (!$check_access) {
          return REVISIONING_LOAD_LATEST;
        }
        $original_vid = $node->vid;
        $node->vid = $latest_vid;
        $node->is_current = revisioning_revision_is_current($node);
        $revision_op = ($op == 'view') ? 'view revisions' : 'edit revisions';
        $access = _revisioning_access_node_revision($revision_op, $node);
        // Restore $node (even though called by value), so that it remains consistent
        $node->vid = $original_vid;
        $node->is_current = revisioning_revision_is_current($node);
        if ($access) {
          return REVISIONING_LOAD_LATEST;
        }
      }
    }
  }
  return REVISIONING_LOAD_CURRENT;
}

/**
 * Display all revisions of the supplied node in a themed table with links for
 * the permitted operations above it.
 * @return render array as returned by drupal_get_form()
 */
function revisioning_node_overview($node) {
  return _theme_revisions_summary($node);
/* Code below works but results in three different looks, prefer consistency
  if ($node->revision_moderation) {
    return _theme_revisions_summary($node);
  }
  if (module_exists("diff")) {
    module_load_include('inc', 'diff', 'diff.pages');
    return diff_diffs_overview($node);
  }
  module_load_include('inc', 'node', 'node.pages');
  return node_revision_overview($node);
*/
}

/**
 * Menu callback for the primary View tab.
 * 
 * This is the same callback as used in core, except that in core current and
 * latest revisions are always the same.
 */
function _revisioning_view($node) {
  if (_revisioning_load_op($node, 'view') == REVISIONING_LOAD_LATEST) {
    $vid_to_load = revisioning_get_latest_revision_id($node->nid);
    $node = node_load($node->nid, $vid_to_load);
  }
  // This is the callback used by node.module for node/%node & node/%node/view
  return node_page_view($node);
}

/**
 * Callback for the primary Edit tab.
 * 
 * This is the same callback as used in core, except that in core current and
 * latest revisions are always the same.
 */
function _revisioning_edit($node) {
  if (_revisioning_load_op($node, 'edit') == REVISIONING_LOAD_LATEST) {
    $vid_to_load = revisioning_get_latest_revision_id($node->nid);
    $node = node_load($node->nid, $vid_to_load);
  }
  _revisioning_set_custom_theme_if_necessary();
  // This is the callback used by node.module for node/%node/edit
  return node_page_edit($node);
}

/**
 * Callback to view a particular revision.
 */
function _revisioning_view_revision($node) {
  // This is the callback used by node.module for node/%node/revisions/%/view
  return node_show($node, TRUE);
}

/**
 * Callback to edit a particular revision.
 * 
 * Note that there is no equivalent of this in core and we should not allow
 * editing of a non-current revision, if $node->revision_moderation is not set.
 * This is the job of the access callback _revisioning_access_node_revision().
 */
function _revisioning_edit_revision($node) {
  _revisioning_set_custom_theme_if_necessary();
  return node_page_edit($node);
}

/**
 * Callback for the primary View and Edit tabs titles
 * @param $node
 * @param $edit, bool
 * @return translatable title string
 */
function _revisioning_title_for_tab($node, $edit = FALSE) {
  if (empty($node->revision_moderation) || $node->num_revisions <= 1) {
    return $edit ? t('Edit') : t('View');
  }
  if (_revisioning_load_op($node, $edit ? 'edit' : 'view') == REVISIONING_LOAD_LATEST) {
    return $edit ? t('Edit latest') : t('View latest');
  }
  return $edit ? t('Edit current') : t('View current');
}

function _revisioning_set_custom_theme_if_necessary() {
  // Use the admin theme if the user specified this at Appearance >> Settings.
  // Note: first tick 'View the administration theme' at People >> Permissions.
  if (variable_get('node_admin_theme', FALSE)) {
    global $theme, $custom_theme;
    $custom_theme = variable_get('admin_theme', $theme);
  }
}

if (module_exists('diff')) {
  /**
   * Use diff's diff_diffs_show() function to compare specific revision to the
   * current one.
   */
  function _revisioning_compare_to_current_revision($node) {
    module_load_include('inc', 'diff', 'diff.pages'); // for diff_diffs_show()
    // Make sure that latest of the two revisions is on the right
    if ($node->current_revision_id > $node->vid) {
      return diff_diffs_show($node, $node->current_revision_id, $node->vid);
    }
    return diff_diffs_show($node, $node->vid, $node->current_revision_id);
  }
}
